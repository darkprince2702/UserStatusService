// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "UserStatusService.h"
#include "Data.h"
#include "Log.h"
#include "Checkpoint.h"
#include "Timer.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TNonblockingServer.h>
#include <Poco/AutoPtr.h>
#include <Poco/Util/XMLConfiguration.h>
#include <boost/algorithm/string.hpp>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace ::userstatusservice;

class UserStatusServiceHandler : virtual public UserStatusServiceIf {
private:
    Poco::AutoPtr<Poco::Util::XMLConfiguration> config;
    boost::shared_ptr<Data> data;
    boost::shared_ptr<Checkpoint> checkPoint;
    boost::shared_ptr<Log> log;
    boost::shared_ptr<Timer> timer;
public:

    UserStatusServiceHandler() :
    config(new Poco::Util::XMLConfiguration("config.xml")) {
        if (config->has("checkPoint")) { // Checkpoint found
            data = boost::make_shared<Data>();
            log = boost::make_shared<Log>();
            std::string cpFrFile = config->getString("checkPoint");
            checkPoint = boost::make_shared<Checkpoint>(cpFrFile, data, log, config);
            // Set checkpoint to now
            checkPoint->setNewCheckpoint();
            std::cout << "checkPoint found, load data from file" << std::endl;
        } else { // No checkpoint, must init
            int blockNum = config->getInt("blockNum");
            int blockSize = config->getInt("blockSize");
            data = boost::make_shared<Data>(blockNum, blockSize);
            data->init();
            log = boost::make_shared<Log>();
            checkPoint = boost::make_shared<Checkpoint>(data, log, config);
            // Set checkpoint to now
            checkPoint->setNewCheckpoint();
            std::cout << "checkPoint not found, initialize data" << std::endl;
        }
        // Create timer and run it
        int interval = config->getInt("logInterval", 120);
        timer = boost::make_shared<Timer>(interval, data, log, checkPoint);
        timer->start();
    }

    void loading() {
        // Load data from dump file
        data->load();
        // Load operations from log
        std::ifstream file;
        file.open(checkPoint->getCheckpoint() + ".log",
                std::ios::in | std::ios::binary);
        if (file.is_open()) {
            std::string line;
            // Get line by line in opened file
            while (std::getline(file, line)) {
                std::vector<std::string> tokens;
                // Split gotten line into tokens
                boost::split(tokens, line, boost::is_any_of(" "));
                if (tokens[3] == "setBit") { // It's set task
                    data->setBit(std::atol(tokens[4].c_str()));
                } else if (tokens[3] == "clearBit") { // It's remove task
                    data->clearBit(std::atol(tokens[4].c_str()));
                }
            }
            file.close();
        }
    }

    bool getUserStatus(const int64_t ID) {
        log->write("getBit " + std::to_string(ID));
        int8_t result = data->getBit(ID);
        assert(result == 0 || result == 1);
        return (result != 0) ? true : false;
    }

    void setUserStatus(const int64_t ID, const bool status) {
        if (status) {
            log->write("setBit " + std::to_string(ID));
            data->setBit(ID);
        } else {
            log->write("clearBit " + std::to_string(ID));
            data->clearBit(ID);
        }
    }
};

int main(int argc, char **argv) {
    Poco::AutoPtr<Poco::Util::XMLConfiguration> config(
            new Poco::Util::XMLConfiguration("config.xml"));
    int port = config->getInt("port", 8000);
    int ioThreadsNum = config->getInt("ioThreadsNum", 2);
    int workerThreadsNum = config->getInt("workerThreadsNum", 4);

    shared_ptr<UserStatusServiceHandler> handler(new UserStatusServiceHandler());
    shared_ptr<TProcessor> processor(new UserStatusServiceProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    boost::shared_ptr<ThreadManager> threadManager =
            ThreadManager::newSimpleThreadManager((size_t) workerThreadsNum);
    boost::shared_ptr<PlatformThreadFactory> threadFactory(new PlatformThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();

    TNonblockingServer server(processor, protocolFactory, port, threadManager);
    server.setNumIOThreads(ioThreadsNum);
    server.serve();

    return 0;
}

